//
// Created by sam on 24/04/18.
//

#include <idt.h>
#include <paging.h>
#include <mem.h>
#include <string.h>
#include <log.h>
#include <heap.h>
#include <maths.h>
#include <util.h>

// Current system creates pages for the whole RAM space at the start
// Maybe add more pages to reflect virtual memory in swapspace.
// Detect reading from virtual memory by page fault exceptions, during which
// the kernel should swap in the associated page and continue

/*
 * Intended memory map:
 *  0 -> 1 MiB = Bootloader, grub stuff
 *  1 MiB -> kernel_end = Kernel code
 *  kernel_end
 */

uint32_t num_pages;
uint32_t* pages_bitmap;

#define BITS_PER_FRAME (sizeof(uint32_t) * 8)
#define FRAME_OFFSET(n) (n / BITS_PER_FRAME)
#define BIT_OFFSET(n) (n % BITS_PER_FRAME)

#define HEAP_INDEX_SIZE 0x20000

page_directory_t* kernel_directory = NULL;
heap_t* kernel_heap = NULL;
extern void* kernel_end;
extern uint32_t placement_address;

void page_fault_handler(arch_registers_t* registers) {
    PANIC("Page fault");
    // TODO: Make this find page to swap in from disk
    // else terminate offending process
}

void paging_init(uint32_t mem_kilobytes, uint32_t desired_placement_addr) {
    // Align the page size to PAGE_SIZE
    // so we don't make a page table that oversteps the total memory
    uint32_t mem_kilobytes_aligned = mem_kilobytes - (mem_kilobytes % PAGE_SIZE);
    // The end of the kernel code, we don't want to allocate memory before this point
    // kernel_end is generated by the linker script (link.ld)
    uint32_t kernel_end_addr = (uint32_t) &kernel_end;
    if(desired_placement_addr < UINT32_MAX && desired_placement_addr >= kernel_end_addr) placement_address = desired_placement_addr;
    else placement_address = kernel_end_addr;

    // This gives a roughly 20MiB heap, depending on our code size and what is allocated before the heap
    // Should be enough right?
    // Align so it falls on page boundary, so we can easily separate it from the user
    // memory that might come afterwards
    uint32_t heap_end = ALIGN_UP(0x1E00000);

    // Calculate the number of pages on this machine (memory / page size)
    num_pages = mem_kilobytes_aligned * 1024 / PAGE_SIZE;
    pages_bitmap = (uint32_t *) kmalloc_a(num_pages * sizeof(uint32_t));

    // Create the kernel directory
    // Identity map from 0x0 to end of kernel heap, after which user space
    // will probably be
    kernel_directory = paging_create_directory(0, heap_end, 0, heap_end);

    // Register page fault interrupt handler
    idt_register_isr_handler(14, page_fault_handler);
    paging_set_directory(kernel_directory);
    // Enable paging
    uint32_t cr0;
    asm ("mov %%cr0, %0": "=r"(cr0));
    cr0 |= 0x8000000;
    asm ("mov %0, %%cr0":: "r"(cr0));

    // Allocate pages to the kernel
    for (uint32_t addr = 0; addr < heap_end; addr += PAGE_SIZE) {
        if(!paging_alloc_page(paging_get_page(addr, kernel_directory))) PANIC("Couldn't allocate a page to the kernel")
    }

    // Heap starts where we finished allocating memory using placement_address
    uint32_t heap_start = ALIGN_UP(placement_address);
    // Create the kernel heap
    kernel_heap = heap_create(heap_start, heap_end, true, true, HEAP_INDEX_SIZE);

}

void set_frame(uint32_t frame) {
    pages_bitmap[FRAME_OFFSET(frame)] |= ((uint32_t) 1 << BIT_OFFSET(frame));
}

void clear_frame(uint32_t frame) {
    pages_bitmap[FRAME_OFFSET(frame)] &= ~((uint32_t) 1 << BIT_OFFSET(frame));
}

bool get_frame(uint32_t frame) {
    return (pages_bitmap[FRAME_OFFSET(frame)] & ((uint32_t) 1 << BIT_OFFSET(frame))) != 0;
}

uint32_t first_free_frame() {
    for (uint32_t i = 0; i < num_pages / BITS_PER_FRAME; ++i) {
        uint32_t frame = pages_bitmap[i];
        // If not full
        if(frame != 0xFFFFFFFF) {
            for (uint32_t j = 0; j < BITS_PER_FRAME; ++j) {
                if ((frame & (1 << j)) == 0) return i * BITS_PER_FRAME + j;
            }
        }
    }
    return UINT32_MAX;
}

// Set a page to be occupied
bool paging_alloc_page(page_table_entry_t *page) {
    uint32_t frame = first_free_frame();
    if(frame < UINT32_MAX) {
        page->present = 1;
        page->physical_addr = frame * PAGE_SIZE;
        page->dirty = 0;
        page->accessed = 0;
        set_frame(frame);
        return true;
    } else PANIC("No free frames");
}

// Free a page's occupation
void paging_free_page(page_table_entry_t *page) {
    uint32_t frame = page->physical_addr / PAGE_SIZE;
    if(get_frame(frame)) {
        clear_frame(frame); // TODO: Explore if freeing causes problems for other pages referencing this frame. Maybe keep reference count?
        page->present = 0;
    } else log_error("Freeing unallocated frame");
}

page_table_entry_t *paging_get_page(uint32_t addr, page_directory_t *directory) {
    uint32_t page = addr / PAGE_SIZE;
    uint32_t table_idx = page / (PAGE_ENTRIES_PER_TABLE * PAGE_TABLE_ENTRIES_PER_DIRECTORY);
    uint32_t page_idx = (page / PAGE_TABLE_ENTRIES_PER_DIRECTORY) / PAGE_ENTRIES_PER_TABLE;
    return &kernel_directory->tables[table_idx]->entries[page_idx];
}

page_dir_entry_t* paging_get_table(uint32_t addr) {
    uint32_t page = addr / PAGE_SIZE;
    uint32_t table_idx = page / (PAGE_ENTRIES_PER_TABLE * PAGE_TABLE_ENTRIES_PER_DIRECTORY);
    return &kernel_directory->entries[table_idx];
}

void paging_set_directory(page_directory_t *directory) {
    asm ("mov %0, %%cr3":: "r"((uint32_t) directory));
}

/*
 * Creates a directory that maps virtual_start -> virtual_end to physical_start -> physical_end
 * Probably not be appropriate for fragmented pages where mapping to free frames
 * would be better
 */
page_directory_t * paging_create_directory(uint32_t phys_start, uint32_t phys_end, uint32_t virtual_start, uint32_t virtual_end) {
    if (phys_start > phys_end) PANIC("Improper start and end physical addresses");
    if(!IS_PAGE_ALIGNED(phys_start) || !IS_PAGE_ALIGNED(phys_end)) PANIC("Physical addresses are not page aligned");
    if (virtual_start > virtual_end) PANIC("Improper start and end virtual addresses");
    if(!IS_PAGE_ALIGNED(virtual_start) || !IS_PAGE_ALIGNED(virtual_end)) PANIC("Virtual addresses are not page aligned");
    if(virtual_end - virtual_start < phys_end - phys_start) PANIC("Virtual space is smaller than physical space");

    page_directory_t *dir = (page_directory_t *) kmalloc(sizeof(page_directory_t));
    if (dir) {
        memset(dir, 0, sizeof(page_directory_t));
        // The physical address to start mapping to
        uint32_t phys_addr = phys_start;
        // Figure out the page and tale we're starting at
        uint32_t page = virtual_start / PAGE_SIZE, table_idx = page / PAGE_ENTRIES_PER_TABLE;
        // Set the tables in this directory until we either reach the maximum
        // mapping address or we've finished the directory
        while ((phys_addr < phys_end) && page < PAGES_PER_DIRECTORY) {
            page_table_t* table = (page_table_t *) kmalloc(sizeof(page_table_t));
            dir->tables[table_idx] = table;
            // Index of the page in the table
            uint32_t page_idx = page % PAGE_ENTRIES_PER_TABLE;
            // Set the pages in this table until we either reach the maximum
            // mapping address or we've finished table
            while (phys_addr < phys_end && page_idx < PAGE_ENTRIES_PER_TABLE) {
                page_table_entry_t* page_entry = &table->entries[page_idx];
                page_entry->physical_addr = phys_addr;
                page_entry->present = 1;
                page_entry->dirty = 0;
                page_entry->caching_disabled = 0;
                page_entry->global = 0;
                page_entry->ignored = 0;
                page_entry->user_level = 0;
                page_entry->writable = 1;
                page_entry->zero = 0;
                page_entry->write_through = 0;
                page_entry->accessed = 0;
                phys_addr += PAGE_SIZE;
                page++;
                page_idx++;
            }
            page_dir_entry_t* table_entry = &dir->entries[table_idx];
            table_entry->accessed = 0;
            table_entry->write_through = 0;
            table_entry->zero = 0;
            table_entry->writable = 1;
            table_entry->user_level = 0;
            table_entry->ignored = 0;
            table_entry->global = 0;
            table_entry->caching_disabled = 0;
            table_entry->present = 1;
            table_entry->four_megabyte_pages = 0;
            // TODO: After paging is enabled, this may not actually be the proper physical address
            // If all page directories are kept in kernel memory and kernel memory is
            // always identity mapped, then there should be no problem.
            // Or fix by always letting alloc_frame give the physical address,
            // as it keeps track of that kind of thing
            table_entry->table_physical_addr = (uint32_t) table;
            table_idx++;
        }
    }
    return dir;
}
